<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>2026 Dream Splendor - èŒè¶£ç››å…¸</title>
    <style>
        /* CSS æ ·å¼ */
        body {
            margin: 0; overflow: hidden;
            background: radial-gradient(circle at center, #ffe6f2 0%, #e6f7ff 60%, #b3e0ff 100%);
            font-family: 'Segoe UI', sans-serif; color: #4a5d7e;
        }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* UI å±‚ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
            padding: 20px; box-sizing: border-box;
        }
        .pointer-events-auto { pointer-events: auto; }

        /* å·¦ä¸Šè§’é¢æ¿ */
        .control-panel {
            background: rgba(255, 255, 255, 0.4); backdrop-filter: blur(10px);
            padding: 15px; border-radius: 15px; border: 1px solid rgba(255, 255, 255, 0.6);
            box-shadow: 0 4px 15px rgba(176, 224, 255, 0.3); max-width: 250px;
            max-height: 80vh; overflow-y: auto; transition: opacity 0.3s;
        }
        .control-panel h3 { margin: 0 0 10px 0; font-size: 16px; color: #ff6b95; }
        
        button, input[type="file"]::file-selector-button {
            background: linear-gradient(135deg, #ffc0cb 0%, #87ceeb 100%);
            border: none; border-radius: 20px; color: white; padding: 8px 15px;
            cursor: pointer; font-size: 12px; margin-bottom: 5px; transition: transform 0.2s;
        }
        button:hover { transform: scale(1.05); }
        input[type="file"] { font-size: 12px; width: 100%; margin-bottom: 5px; }
        .clear-data-btn { background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%) !important; width: 100%; margin-top: 10px; }

        /* æ’­æ”¾åˆ—è¡¨ */
        .playlist-box {
            margin-top: 5px; margin-bottom: 10px; max-height: 100px; overflow-y: auto;
            background: rgba(0, 0, 0, 0.05); border-radius: 8px; padding: 5px;
        }
        .playlist-box::-webkit-scrollbar { width: 4px; }
        .playlist-box::-webkit-scrollbar-thumb { background: #ffc0cb; border-radius: 2px; }
        .track-item {
            font-size: 11px; padding: 4px 8px; cursor: pointer; color: #555;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .track-item:hover { background: rgba(255, 255, 255, 0.5); color: #ff6b95; }
        .track-item.active { color: #ff6b95; font-weight: bold; background: rgba(255, 255, 255, 0.8); border-radius: 4px; }

        /* å³ä¸‹è§’é¢æ¿ */
        .ai-panel { align-self: flex-end; display: flex; flex-direction: column; align-items: flex-end; gap: 10px; }
        .camera-box { position: relative; width: 160px; height: 120px; background: #000; border-radius: 12px; overflow: hidden; border: 2px solid #fff; }
        #webcam, #output_canvas { position: absolute; width: 100%; height: 100%; left: 0; top: 0; transform: scaleX(-1); }
        .guide-box { background: rgba(255, 255, 255, 0.5); backdrop-filter: blur(8px); padding: 15px; border-radius: 12px; font-size: 12px; max-width: 220px; text-align: right; }
        .guide-item { margin: 4px 0; display: flex; align-items: center; justify-content: flex-end; gap: 8px;}
        .icon { font-size: 16px; }

        /* Loading & UI */
        #loading-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, #fff0f5, #e0f7fa);
            z-index: 200; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: opacity 1s;
        }
        .loader { border: 5px solid #f3f3f3; border-top: 5px solid #ff6b95; border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        #countdown-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 100;
            display: none; pointer-events: auto; flex-direction: column; align-items: center; justify-content: center;
            background: rgba(255, 240, 245, 0.2); backdrop-filter: blur(2px);
        }
        .countdown-title { font-size: 24px; color: #87CEEB; letter-spacing: 2px; margin-bottom: 20px; text-shadow: 0 0 10px rgba(135, 206, 235, 0.5); }
        .countdown-number { font-size: 120px; font-weight: bold; color: #87CEEB; text-shadow: 0 0 20px rgba(135, 206, 235, 0.8); transition: all 0.2s; }
        .pulse { animation: pulse-anim 1s infinite; }
        @keyframes pulse-anim { 0% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.05); opacity: 0.8; } 100% { transform: scale(1); opacity: 1; } }
        #skip-countdown-btn {
            margin-top: 40px; background: rgba(255, 255, 255, 0.3); border: 2px solid #87CEEB; color: #87CEEB;
            padding: 10px 30px; border-radius: 30px; cursor: pointer; font-size: 16px; font-weight: bold; transition: all 0.3s;
        }
        #skip-countdown-btn:hover { background: #87CEEB; color: white; transform: scale(1.1); }
        
        #bgm-input, #img-input { display: none; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm",
                "@tweenjs/tween.js": "https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@23.1.1/dist/tween.esm.js"
            }
        }
    </script>
</head>
<body>

    <div id="loading-screen">
        <div class="loader"></div>
        <h2 style="color: #ff6b95; margin-top: 20px;">2026 Dream Splendor</h2>
        <p id="loading-text" style="color: #888;">æ­£åœ¨åŠ è½½ AI å¼•æ“...</p>
        <button id="start-btn" style="display:none; font-size: 18px; padding: 10px 30px; margin-top: 20px;">å¼€å¯ç››å…¸</button>
    </div>

    <div id="countdown-overlay">
        <div class="countdown-title" id="cd-title">æ–°å¹´å€’è®¡æ—¶ Loading...</div>
        <div class="countdown-number" id="cd-number">--</div>
        <button id="skip-countdown-btn">ğŸš€ ç«‹å³å¼€å§‹</button>
    </div>

    <div id="ui-layer">
        <div class="control-panel pointer-events-auto">
            <h3>âœ¨ è®°å¿†æ—¶åˆ»</h3>
            <button onclick="document.getElementById('img-input').click()">ğŸ“¸ ä¸Šä¼ ç…§ç‰‡ä¸Šå¢™</button>
            <input type="file" id="img-input" accept="image/*" multiple>
            <div style="height:10px;"></div>
            <h3>ğŸµ æ°›å›´éŸ³ä¹</h3>
            <button onclick="document.getElementById('bgm-input').click()">ğŸ“‚ æ·»åŠ æ­Œæ›²</button>
            <input type="file" id="bgm-input" accept="audio/*" multiple>
            <div id="playlist-container" class="playlist-box" style="display:none;"></div>
            <button id="play-pause-btn">â–¶ æ’­æ”¾ / æš‚åœ</button>
            <div style="margin-top:10px; border-top: 1px solid #ccc; padding-top:5px;">
                <button id="fullscreen-btn">â›¶ å…¨å±ä½“éªŒ</button>
                <button id="clear-db-btn" class="clear-data-btn">ğŸ—‘ï¸ æ¸…ç©ºæœ¬åœ°ç¼“å­˜</button>
            </div>
        </div>
        <div class="ai-panel pointer-events-auto">
            <div class="guide-box">
                <div style="font-weight: bold; margin-bottom: 5px; color:#ff6b95">AI æ‰‹åŠ¿é­”æ³•</div>
                <div class="guide-item">èšåˆ (çˆ±å¿ƒ) <span class="icon">âœŠ</span></div>
                <div class="guide-item">å˜èº« (èŒå® ) <span class="icon">ğŸ–</span></div>
                <div class="guide-item">ç¼©æ”¾ (Zoom) <span class="icon">ğŸ‘Œ</span></div>
                <div class="guide-item">ç‚¹å‡»ç…§ç‰‡ <span class="icon">ğŸ–±ï¸</span></div>
            </div>
            <div class="camera-box"><video id="webcam" autoplay playsinline></video><canvas id="output_canvas"></canvas></div>
        </div>
    </div>

    <div id="canvas-container"></div>
    <audio id="bgm-player" loop></audio>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';
        import TWEEN from '@tweenjs/tween.js';

        // ==========================================
        //  ğŸ”´ è¿™é‡Œæ˜¯ç»™æœ‹å‹çœ‹çš„é…ç½®åŒº (SHARED MEMORY)
        // ==========================================
        // è¯·å°†ç…§ç‰‡å’ŒéŸ³ä¹æ–‡ä»¶æ”¾åœ¨å’Œ index.html åŒä¸€ä¸ªæ–‡ä»¶å¤¹é‡Œ (æˆ–è€… assets/ æ–‡ä»¶å¤¹)
        // ç„¶ååœ¨è¿™é‡Œå†™ä¸Šæ–‡ä»¶åã€‚ä¾‹å¦‚: 'my_photo.jpg' æˆ– 'assets/song.mp3'
        const SHARED_ASSETS = {
            images: [
                   '1 (2).jpg', 
                   '1 (3).jpg',
                   '1 (4).jpg',
                   '1 (5).jpg',
                   '1 (6).jpg',
                   '1 (7).jpg',
                   '1 (8).jpg',
                   '1 (9).jpg',
                   '1 (10).jpg',
                   '1 (11).jpg'
            ],
            music: [
                // ç¬¬ä¸€é¦–æ­Œ
                { name: 'æˆ‘', url: '1. æˆ‘.mp3' }, 
                
                // ç¬¬äºŒé¦–æ­Œ (æ³¨æ„ä¸Šä¸€è¡Œçš„å¤§æ‹¬å·åé¢è¦æœ‰é€—å·)
                { name: 'çˆ±ä½ ', url: '2. çˆ±ä½ .mp3' },

                // ç¬¬ä¸‰é¦–æ­Œ
                { name: 'ä¸€åƒä¸€ä¸‡é', url: '3. ä¸€åƒä¸€ä¸‡é.mp3' } 
            ]
        };
        // ==========================================

        // --- IndexedDB (æœ¬åœ°æŒä¹…åŒ–) ---
        const DB_NAME = 'DreamSplendorDB'; const DB_VERSION = 1; let db;
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onupgradeneeded = (e) => {
                    db = e.target.result;
                    if (!db.objectStoreNames.contains('photos')) db.createObjectStore('photos', { keyPath: 'id', autoIncrement: true });
                    if (!db.objectStoreNames.contains('music')) db.createObjectStore('music', { keyPath: 'id', autoIncrement: true });
                };
                request.onsuccess = (e) => { db = e.target.result; resolve(db); };
                request.onerror = (e) => reject(e);
            });
        }
        function saveToDB(storeName, fileBlob, fileName) {
            return new Promise((resolve) => {
                const t = db.transaction([storeName], 'readwrite');
                t.objectStore(storeName).add({ file: fileBlob, name: fileName, date: new Date() });
                t.oncomplete = () => resolve();
            });
        }
        function loadFromDB(storeName) {
            return new Promise((resolve) => {
                const t = db.transaction([storeName], 'readonly');
                const req = t.objectStore(storeName).getAll();
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => resolve([]);
            });
        }
        function clearDB() {
            return new Promise((resolve) => {
                const t = db.transaction(['photos', 'music'], 'readwrite');
                t.objectStore('photos').clear(); t.objectStore('music').clear();
                t.oncomplete = () => { alert("æœ¬åœ°ç¼“å­˜å·²æ¸…ç©º"); location.reload(); };
            });
        }

        // --- Config & State ---
        const CONFIG = { count: 1500, colors: [0xffc0cb, 0x87ceeb, 0xff69b4, 0x98fb98], bloomStrength: 0.6, bloomRadius: 0.4, bloomThreshold: 0.4 };
        const STATE = { mode: 'intro', isZoomed: false, handDetected: false, rotationSpeed: 0.001, focusedPhoto: null };

        let scene, camera, renderer, composer, controls;
        let instancedMeshes = [], photoMeshes = [], goldParticles, instanceData = []; 
        let raycaster, mouse;

        // --- Init ---
        async function init() {
            try {
                const container = document.getElementById('canvas-container');
                scene = new THREE.Scene(); scene.background = null; scene.fog = new THREE.FogExp2(0xfff0f5, 0.002);
                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 0, 80);
                
                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.toneMapping = THREE.ReinhardToneMapping;
                container.appendChild(renderer.domElement);

                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true; controls.dampingFactor = 0.05; controls.enablePan = false;
                controls.minDistance = 10; controls.maxDistance = 150;

                // Raycaster for click interaction
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();
                window.addEventListener('click', onMouseClick, false);

                const renderScene = new RenderPass(scene, camera);
                const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.threshold = CONFIG.bloomThreshold; bloomPass.strength = CONFIG.bloomStrength; bloomPass.radius = CONFIG.bloomRadius;
                composer = new EffectComposer(renderer); composer.addPass(renderScene); composer.addPass(bloomPass);

                scene.add(new THREE.AmbientLight(0xffffff, 0.8));
                const dirLight = new THREE.DirectionalLight(0xffffff, 1.5); dirLight.position.set(10, 20, 10); scene.add(dirLight);
                const pointLight = new THREE.PointLight(0xff6b95, 2, 50); pointLight.position.set(0, 5, 0); scene.add(pointLight);

                updateLoadingText("åˆå§‹åŒ–æ•°æ®åº“...");
                await initDB();
                updateLoadingText("è¿æ¥ AI å¼•æ“...");
                await setupMediaPipe();
                finishLoading();
                window.addEventListener('resize', onWindowResize);
                setupUI();
                animate();

            } catch (err) { console.error("Init Error:", err); finishLoading(); }
        }

        function updateLoadingText(text) { const el = document.getElementById('loading-text'); if(el) el.innerText = text; }
        function finishLoading() {
            document.querySelector('.loader').style.display = 'none';
            updateLoadingText("å‡†å¤‡å°±ç»ª");
            const startBtn = document.getElementById('start-btn');
            startBtn.style.display = 'block';
            startBtn.addEventListener('click', startIntro);
        }

        // --- Interaction: Click to Zoom Photo ---
        function onMouseClick(event) {
            // å¦‚æœç‚¹å‡»çš„æ˜¯ UI ä¸Šçš„å…ƒç´ ï¼Œå¿½ç•¥
            if (event.target.closest('button') || event.target.closest('.control-panel')) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            // å¦‚æœå½“å‰å·²ç»èšç„¦äº†æŸå¼ ç…§ç‰‡ï¼Œå†æ¬¡ç‚¹å‡»åˆ™è¿˜åŸ
            if (STATE.focusedPhoto) {
                unzoomPhoto();
                return;
            }

            // æ£€æµ‹ç‚¹å‡»
            const intersects = raycaster.intersectObjects(photoMeshes.map(pm => pm.mesh), true);
            if (intersects.length > 0) {
                // æ‰¾åˆ°å¯¹åº”çš„ photoMesh å¯¹è±¡
                const object = intersects[0].object;
                const parent = object.parent; // å› ä¸ºæœ‰ border
                const targetMesh = parent.isMesh ? parent : object;
                const pm = photoMeshes.find(p => p.mesh === targetMesh || p.mesh === object);
                
                if (pm) zoomPhoto(pm);
            }
        }

        function zoomPhoto(pm) {
            STATE.focusedPhoto = pm;
            pm.isFocused = true; // æ ‡è®°ä¸å‚ä¸å¸¸è§„åŠ¨ç”»
            
            // è®¡ç®—ç›¸æœºå‰æ–¹çš„ç‚¹
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            const targetPos = camera.position.clone().add(dir.multiplyScalar(15)); // è·ç¦»ç›¸æœº15å•ä½

            // åŠ¨ç”»ç§»åŠ¨
            new TWEEN.Tween(pm.mesh.position).to(targetPos, 1000).easing(TWEEN.Easing.Exponential.Out).start();
            
            // åŠ¨ç”»æ—‹è½¬ (é¢å‘ç›¸æœº)
            const targetQuat = camera.quaternion.clone();
            new TWEEN.Tween(pm.mesh.quaternion).to(targetQuat, 1000).easing(TWEEN.Easing.Exponential.Out).start();

            // åŠ¨ç”»ç¼©æ”¾ (ç¨å¾®æ”¾å¤§)
            new TWEEN.Tween(pm.mesh.scale).to({x: 1.5, y: 1.5, z: 1.5}, 1000).start();

            // éšè— UI é˜²æ­¢å¹²æ‰°
            document.querySelector('.control-panel').style.opacity = '0';
        }

        function unzoomPhoto() {
            if (!STATE.focusedPhoto) return;
            const pm = STATE.focusedPhoto;
            
            // è¿˜åŸä½ç½®
            const targetPos = (STATE.mode === 'tree') ? pm.treePos : pm.scatterPos;
            new TWEEN.Tween(pm.mesh.position).to(targetPos, 800).easing(TWEEN.Easing.Back.Out).onComplete(() => {
                pm.isFocused = false;
            }).start();

            // è¿˜åŸç¼©æ”¾
            new TWEEN.Tween(pm.mesh.scale).to({x:1, y:1, z:1}, 800).start();

            // è¿˜åŸæ—‹è½¬ (LookAt Camera åœ¨ animate é‡Œæ¯å¸§ä¼šæ‰§è¡Œï¼Œæ‰€ä»¥åªè¦ä½ç½®å¯¹äº†å°±è¡Œï¼Œæˆ–è€…é‡ç½®æ—‹è½¬)
            pm.mesh.lookAt(camera.position); 

            STATE.focusedPhoto = null;
            document.querySelector('.control-panel').style.opacity = '1';
        }

        // --- Start Intro ---
        function startIntro() {
            const screen = document.getElementById('loading-screen'); screen.style.opacity = 0; setTimeout(() => screen.remove(), 1000);
            const overlay = document.getElementById('countdown-overlay'); 
            const title = document.getElementById('cd-title'); const number = document.getElementById('cd-number');
            overlay.style.display = 'flex';
            const skipBtn = document.getElementById('skip-countdown-btn');
            let checkTimer = null;

            skipBtn.onclick = () => {
                if(checkTimer) clearInterval(checkTimer); overlay.style.opacity = 0;
                setTimeout(() => { overlay.style.display = 'none'; initMainScene(); }, 500);
            };

            const TARGET_DATE = new Date("2026-01-01T00:00:00").getTime();
            const START_SHOWING_NUMBERS = TARGET_DATE - (60 * 1000); 

            checkTimer = setInterval(() => {
                const now = new Date(); const t = now.getTime(); const dist = TARGET_DATE - t;
                if (dist <= 0) {
                    clearInterval(checkTimer); number.innerText = "2026"; number.style.fontSize = "120px"; number.classList.add('pulse');
                    title.innerText = "æ–°å¹´å¿«ä¹ Happy New Year"; skipBtn.style.display = 'none';
                    setTimeout(() => { overlay.style.opacity = 0; setTimeout(() => { overlay.style.display = 'none'; initMainScene(); }, 1000); }, 2000);
                } else if (t >= START_SHOWING_NUMBERS) {
                    title.innerText = "å³å°†è¿ˆå…¥ 2026"; number.innerText = Math.floor(dist / 1000); number.classList.add('pulse'); number.style.fontSize = "150px";
                } else {
                    title.innerText = "æ–°å¹´å€’è®¡æ—¶ Loading..."; number.innerText = now.toTimeString().split(' ')[0]; number.classList.remove('pulse'); number.style.fontSize = "60px";
                }
            }, 1000);
        }

        // --- Main Scene ---
        function initMainScene() {
            STATE.mode = 'tree';
            const geos = [ new THREE.SphereGeometry(0.4,16,16), new THREE.IcosahedronGeometry(0.35,1), new THREE.SphereGeometry(0.25,12,12), new THREE.IcosahedronGeometry(0.3,2) ];
            const mats = [
                new THREE.MeshStandardMaterial({color:CONFIG.colors[0], roughness:0.6, metalness:0.1, emissive:CONFIG.colors[0], emissiveIntensity:0.3}),
                new THREE.MeshStandardMaterial({color:CONFIG.colors[1], roughness:0.5, metalness:0.2, emissive:CONFIG.colors[1], emissiveIntensity:0.3}),
                new THREE.MeshPhysicalMaterial({color:CONFIG.colors[2], transmission:0.5, opacity:0.9, roughness:0.2, ior:1.4, emissive:CONFIG.colors[2], emissiveIntensity:0.2}),
                new THREE.MeshStandardMaterial({color:CONFIG.colors[3], roughness:0.6, metalness:0.1, emissive:CONFIG.colors[3], emissiveIntensity:0.3})
            ];
            geos.forEach((geo,i) => {
                const mesh = new THREE.InstancedMesh(geo, mats[i], CONFIG.count/4);
                mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage); scene.add(mesh); instancedMeshes.push(mesh);
            });

            function getHeartPos(i, total) {
                const t = Math.random()*Math.PI*2; const s = Math.cbrt(Math.random()); 
                const hx = 16*Math.pow(Math.sin(t),3); const hy = 13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t);
                return new THREE.Vector3(hx*0.8*s, hy*0.8*s+5, (Math.random()-0.5)*8*s); 
            }
            function getRabbitPos(i, total) {
                const rand = Math.random(); let pos = new THREE.Vector3();
                if (rand < 0.6) {
                    const r=9*Math.cbrt(Math.random()), phi=Math.acos(-1+2*Math.random()), theta=Math.random()*Math.PI*2;
                    pos.set(r*Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta), r*Math.cos(phi)*0.8);
                } else {
                    const we=rand<0.8?-1:1, r=3*Math.sqrt(Math.random()), h=Math.random()*12, ang=Math.random()*Math.PI*2;
                    pos.set((Math.cos(ang)*r + we*5)*1.2, h+6, Math.sin(ang)*r);
                } return pos;
            }
            function getSheepHeadPos(i, total) {
                const rand=Math.random(); let pos=new THREE.Vector3();
                if(rand<0.4) {
                    const r=5+Math.random()*2, phi=Math.acos(-1+2*Math.random()), theta=Math.random()*Math.PI*2;
                    pos.set(r*Math.sin(phi)*Math.cos(theta)*1.4, r*Math.sin(phi)*Math.sin(theta)*0.8, r*Math.cos(phi)*0.7);
                } else if(rand<0.8) {
                    const r=3.5+Math.random()*1.5, phi=Math.random()*Math.PI/2, theta=Math.random()*Math.PI*2;
                    pos.set(r*Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta), r*Math.cos(phi)*0.8); pos.y+=3.5;
                } else {
                    const il=rand<0.9?-1:1, t=Math.random()*Math.PI, ex=Math.sin(t)*2*il, ey=-t*6*0.8;
                    pos.set(ex+il*6, ey+2, Math.cos(t)* (Math.random()-0.5)+2);
                } return pos;
            }

            const total=CONFIG.count, dummy=new THREE.Object3D(); let indexPerMesh=[0,0,0,0];
            for(let i=0; i<total; i++) {
                const type=i%4, idx=indexPerMesh[type];
                const tree=getHeartPos(i,total), rabbit=getRabbitPos(i,total), sheep=getSheepHeadPos(i,total);
                const current=new THREE.Vector3((Math.random()-0.5)*100, (Math.random()-0.5)*100, (Math.random()-0.5)*100);
                instanceData.push({type, index:idx, currentPos:current, targetPos:tree, treePos:tree, rabbitPos:rabbit, sheepPos:sheep});
                indexPerMesh[type]++;
            }

            const pGeo=new THREE.BufferGeometry(), pPos=[];
            for(let k=0; k<800; k++) pPos.push((Math.random()-0.5)*60, (Math.random()-0.5)*60, (Math.random()-0.5)*60);
            pGeo.setAttribute('position', new THREE.Float32BufferAttribute(pPos, 3));
            goldParticles = new THREE.Points(pGeo, new THREE.PointsMaterial({color:0xffd700, size:0.2, transparent:true, opacity:0.6}));
            scene.add(goldParticles);
        }

        function switchState(newState) {
            if (STATE.mode === newState) return;
            let animalType = 'rabbit'; if (newState === 'scatter') animalType = Math.random() > 0.5 ? 'rabbit' : 'sheep';
            STATE.mode = newState;
            instanceData.forEach(data => {
                if (newState === 'tree') data.targetPos = data.treePos;
                else if (newState === 'scatter') data.targetPos = (animalType === 'rabbit') ? data.rabbitPos : data.sheepPos;
            });
            photoMeshes.forEach(pm => {
                // å¦‚æœç…§ç‰‡æ­£åœ¨è¢«æŸ¥çœ‹ï¼Œä¸æ”¹å˜ç›®æ ‡ä½ç½®ï¼Œé¿å…é£èµ°
                if (!pm.isFocused) pm.targetPos = (newState === 'tree') ? pm.treePos : pm.scatterPos;
            });
        }

        function handleZoom(doZoom) {
            // å¦‚æœæ­£åœ¨æŸ¥çœ‹ç…§ç‰‡ï¼Œç¦ç”¨æ‰‹åŠ¿ç¼©æ”¾
            if (STATE.focusedPhoto) return;
            if (STATE.isZoomed === doZoom) return; STATE.isZoomed = doZoom;
            new TWEEN.Tween(camera.position).to({ z: doZoom ? 25 : 80 }, 1000).easing(TWEEN.Easing.Quadratic.Out).start();
        }

        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time); if(controls) controls.update();
            if (instanceData.length === 0) { composer.render(); return; }

            const dummy = new THREE.Object3D(), lerpSpeed = 0.05;
            for(let i=0; i<instanceData.length; i++) {
                const d = instanceData[i]; d.currentPos.lerp(d.targetPos, lerpSpeed);
                const noise = Math.sin(time * 0.001 + d.index) * 0.05;
                dummy.position.copy(d.currentPos); dummy.position.y += noise;
                dummy.rotation.x += 0.01; dummy.rotation.y += 0.01; dummy.updateMatrix();
                instancedMeshes[d.type].setMatrixAt(d.index, dummy.matrix);
            }
            instancedMeshes.forEach(mesh => mesh.instanceMatrix.needsUpdate = true);
            
            // æ›´æ–°ç…§ç‰‡ä½ç½®
            photoMeshes.forEach(pm => {
                if (pm.isFocused) {
                    // å¦‚æœèšç„¦ï¼Œåªè®©å®ƒè½»å¾®æ¼‚æµ®ï¼Œä¸è·Ÿéšå…¨å±€ç§»åŠ¨
                    pm.mesh.lookAt(camera.position);
                } else {
                    pm.mesh.position.lerp(pm.targetPos, lerpSpeed);
                    pm.mesh.lookAt(camera.position);
                }
            });

            if (STATE.mode === 'scatter') {
                const rSpeed = STATE.handDetected ? STATE.rotationSpeed * 5 : 0;
                if(STATE.handDetected && !STATE.focusedPhoto) scene.rotation.y += rSpeed;
            }
            if(goldParticles) goldParticles.rotation.y -= 0.001;
            composer.render();
        }

        let vision, handLandmarker;
        async function setupMediaPipe() {
            try {
                vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                    runningMode: "VIDEO", numHands: 1
                });
                startWebcam();
            } catch (e) { console.warn("AI Fail", e); document.querySelector('.guide-box').innerHTML += "<div style='color:red'>AIæœåŠ¡å¤±è´¥</div>"; }
        }
        function startWebcam() {
            const video = document.getElementById("webcam"), canvas = document.getElementById("output_canvas"), canvasCtx = canvas.getContext("2d");
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) return;
            navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => { video.srcObject = stream; video.addEventListener("loadeddata", predictWebcam); });
            let lastVideoTime = -1;
            function predictWebcam() {
                if(video.videoWidth) { canvas.width = video.videoWidth; canvas.height = video.videoHeight; }
                let startTimeMs = performance.now();
                if (lastVideoTime !== video.currentTime && handLandmarker) {
                    lastVideoTime = video.currentTime;
                    const results = handLandmarker.detectForVideo(video, startTimeMs);
                    canvasCtx.save(); canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
                    if (results.landmarks && results.landmarks.length > 0) {
                        STATE.handDetected = true; drawHand(canvasCtx, results.landmarks[0]); analyzeGesture(results.landmarks[0]);
                    } else STATE.handDetected = false;
                    canvasCtx.restore();
                }
                window.requestAnimationFrame(predictWebcam);
            }
        }
        function drawHand(ctx, lm) { ctx.fillStyle = "#ff6b95"; ctx.strokeStyle = "#87ceeb"; ctx.lineWidth = 2; lm.forEach(p => { ctx.beginPath(); ctx.arc(p.x * ctx.canvas.width, p.y * ctx.canvas.height, 3, 0, 2 * Math.PI); ctx.fill(); }); }
        function analyzeGesture(lm) {
            const wrist = lm[0], thumb = lm[4], index = lm[8];
            const pinchDist = Math.hypot(thumb.x - index.x, thumb.y - index.y);
            if (pinchDist < 0.05) { handleZoom(true); return; } else handleZoom(false);
            const tips = [lm[8], lm[12], lm[16], lm[20]];
            let avgDist = 0; tips.forEach(tip => avgDist += Math.hypot(tip.x - wrist.x, tip.y - wrist.y)); avgDist /= 4;
            if (avgDist < 0.25) switchState('tree'); else if (avgDist > 0.4) switchState('scatter');
            if (STATE.mode === 'scatter') { if (wrist.x < 0.4) STATE.rotationSpeed = -0.01; else if (wrist.x > 0.6) STATE.rotationSpeed = 0.01; else STATE.rotationSpeed = 0; }
        }

        // --- UI & Persistence Logic ---
        function setupUI() {
            // 1. Load Data
            loadFromDB('photos').then(items => { items.forEach(item => { const url = URL.createObjectURL(item.file); createPhotoMesh(url); }); });
            loadFromDB('music').then(items => { 
                items.forEach(item => { 
                    playlist.push({name: item.name, url: URL.createObjectURL(item.file)}); 
                });
                if(items.length > 0) { playlistContainer.style.display = 'block'; renderPlaylist(); }
            });
            
            // 2. Load Shared Assets (ç»™æœ‹å‹çœ‹çš„é¢„è®¾)
            SHARED_ASSETS.images.forEach(url => createPhotoMesh(url));
            SHARED_ASSETS.music.forEach(track => {
                playlist.push(track);
                playlistContainer.style.display = 'block';
                renderPlaylist();
            });

            // 3. Listeners
            const imgInput = document.getElementById('img-input');
            imgInput.addEventListener('change', (e) => {
                const files = Array.from(e.target.files);
                files.forEach(file => {
                    saveToDB('photos', file, file.name);
                    createPhotoMesh(URL.createObjectURL(file));
                });
            });

            const bgmInput = document.getElementById('bgm-input');
            const audioPlayer = document.getElementById('bgm-player');
            const playlistContainer = document.getElementById('playlist-container');
            const playPauseBtn = document.getElementById('play-pause-btn');
            
            let playlist = []; let currentTrackIndex = -1;

            bgmInput.addEventListener('change', (e) => {
                const files = Array.from(e.target.files); if (files.length === 0) return;
                files.forEach(file => {
                    saveToDB('music', file, file.name);
                    playlist.push({ name: file.name, url: URL.createObjectURL(file) });
                });
                playlistContainer.style.display = 'block'; renderPlaylist();
                if (audioPlayer.paused && currentTrackIndex === -1) playTrack(playlist.length - files.length);
            });

            document.getElementById('clear-db-btn').addEventListener('click', clearDB);

            function renderPlaylist() {
                playlistContainer.innerHTML = '';
                playlist.forEach((track, index) => {
                    const div = document.createElement('div'); div.className = 'track-item';
                    if (index === currentTrackIndex) div.classList.add('active');
                    div.innerText = track.name; div.onclick = () => playTrack(index);
                    playlistContainer.appendChild(div);
                });
            }
            function playTrack(index) {
                if (index < 0 || index >= playlist.length) return;
                currentTrackIndex = index; audioPlayer.src = playlist[index].url; audioPlayer.play();
                playPauseBtn.innerText = "â¸ æš‚åœ"; renderPlaylist();
            }
            audioPlayer.addEventListener('ended', () => {
                let nextIndex = currentTrackIndex + 1; if (nextIndex >= playlist.length) nextIndex = 0;
                playTrack(nextIndex);
            });
            playPauseBtn.addEventListener('click', () => {
                if (playlist.length === 0) { alert("è¯·å…ˆä¸Šä¼ æ­Œæ›²~"); return; }
                if (audioPlayer.paused) { audioPlayer.play(); playPauseBtn.innerText = "â¸ æš‚åœ"; }
                else { audioPlayer.pause(); playPauseBtn.innerText = "â–¶ æ’­æ”¾"; }
            });
            document.getElementById('fullscreen-btn').addEventListener('click', () => { if (!document.fullscreenElement) document.documentElement.requestFullscreen(); else document.exitFullscreen(); });
        }

        function createPhotoMesh(imgUrl) {
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(imgUrl, (tex) => {
                const aspect = tex.image.width / tex.image.height;
                const width = 4; const height = width / aspect;
                const geo = new THREE.PlaneGeometry(width, height);
                const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(geo, mat);
                const border = new THREE.Mesh(new THREE.PlaneGeometry(width + 0.2, height + 0.2), new THREE.MeshBasicMaterial({ color: 0xffc0cb }));
                border.position.z = -0.01; mesh.add(border);
                scene.add(mesh);
                const theta = Math.random() * Math.PI * 2; const r = 25;
                const treePos = new THREE.Vector3(Math.cos(theta)*r, (Math.random()*20)-5, Math.sin(theta)*r);
                const scatterPos = new THREE.Vector3((Math.random()-0.5)*90, (Math.random()-0.5)*90, (Math.random()-0.5)*90);
                const pm = { mesh: mesh, treePos: treePos, scatterPos: scatterPos, targetPos: (STATE.mode === 'tree') ? treePos : scatterPos, isFocused: false };
                mesh.position.copy(pm.targetPos); mesh.scale.set(0,0,0);
                new TWEEN.Tween(mesh.scale).to({x:1, y:1, z:1}, 600).easing(TWEEN.Easing.Back.Out).start();
                photoMeshes.push(pm);
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
